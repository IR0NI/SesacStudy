
// 이 줄은 코드에 영향을 줄 수 없다.
// 앞에 #이 붙으면 전처리기이다.
// 전처리기는 컴파일 단계 전에 처리하는 구문이다.
// #include는 뒤에 있는 헤더파일을 여기에 포함시켜 해당 헤더파일의
// 코드를 여기에서 사용할 수 있도록 한다.
#include <iostream>

// using namespace를 해주면 뒤에 있는 namespace를 여기에서 
// 사용하겠다고 하여 std:: 를 빼주고 사용이 가능하다.(std:: 생략가능)
//using namespace std;

/*
일자 : 25. 04. 24.
작성자 : 박성우
내용 : 콘솔 프로젝트 진입점 함수
사용변수 : 
*/
void main()
{
	// '' : 문자 1개를 표현한다. 알파벳 혹은 숫자.
	// "" : 문자 여러개를 표현한다.(문자열)
	// 코드 줄의 작성이 끝날때 ; 을 붙여주어야 한다.
	// \n : 개행문자
	printf("출력 \n테스트\n");
	printf("두번째 출력\n");

	// :: 스코프 연산자이다. 범위를 지정할 때 사용한다.
	// std::cout 이렇게 표현하면 std namespace 안의 cout이다.
	std::cout << "세번째 출력\n";

	//cout << "네번째 출력";

	/*
	여러줄 주석.
	용량의 최소단위 : bit
	1bit는 0, 1 둘중에 하나의 값을 저장할 수 있는 공간이다.
	1byte : 8bit
	1kbyte : 1024byte
	1mbyte : 1024kbyte
	1gbyte : 1024mbyte
	1tbyte : 1024gbyte

	00, 01, 10, 11
	000, 001, 010, 011, 100, 101, 110, 111

	변수와 상수
	변수 : 값을 변경할 수 있는 숫자이다.
	상수 : 값을 변경할 수 없는 숫자이다.
	메모리에 공간을 만들고 변수나 상수의 값을 저장해둔다.

	크기 : byte단위
	문자 표현시 한글, 한자는 2바이트를 차지한다.
	문자는 값을 저장하고 값에 해당하는 문자를 ASCII 코드에서 찾아서
	표현한다.

	signed : +, - 부호가 있다.
	unsigned : 부호가 없다.(+만 있다.)
	기본은 signed 이다.

	표현범위를 벗어나면 동작되는 방식
	최대값 이상 : 최소값으로 전환
	최소값 이하 : 최대값으로 전환
	INT_MAX : int로 표현할 수 있는 최대값
	INT64_MAX : __int64로 표현할 수 있는 최대값

	타입		|	크기	|	종류		|	표현범위	
	bool	|	1	|	참/거짓	|	false(0) - true(1)
	char	|	1	|	문자		|	-128 ~ 127
	short	|	2	|	정수		|	-32768 ~ 32767
	int		|	4	|	정수		|	-2147483648 ~ 2147483647
	__int64	|	8	|	정수		|	
	float	|	4	|	실수		|
	double	|	8	|	실수		|

	변수 선언 방법 : 변수타입 변수명;
	변수명은 알파벳, 숫자, _ 만 사용 가능.
	변수명의 시작은 알파벳, _ 만 가능.
	*/

	// 변수는 선언하면 쓰레기값이 들어가 있다.
	// 그렇기 때문에 선언과 동시에 초기화를 해주고 사용하는것이
	// 안전하다.
	bool	TestBool = false;
	TestBool = true;

	int		Number = 100;

	// 변수 타입 왼쪽에 const를 붙이면 상수 선언이 된다.
	const int	cNumber = 200;
	//cNumber = 300;

	char	Text = 'C';

	// -128 ~ 127 사이의 값을 unsigned를 붙여 0 ~ 255로
	// 표현범위를 바꿔주었다.
	unsigned char	Text1 = 203;

	// -32768 ~ 32767
	short	Number1 = -32769;

	// cout에 변수를 넣으면 변수가 가지고 있는 값을 출력한다.
	std::cout << Number1 << "\n";

	// 소수점 뒤에 f를 붙이면 float타입 실수가 된다.
	// f가 없으면 double 타입 실수가 된다.
	float	Number2 = 3.1456712345678f;

	std::cout << Number2 << "\n";;

	double	Number3 = 3.123532563256235;


	Number = 3.14f;

	std::cout << Number << "\n";

	/*
	= : 대입연산자. 오른쪽의 값을 왼쪽의 변수에 대입한다.

	연산자 우선순위 : 연산자들끼리 연산되는 순서를 결정.

	수학 : (), {}, []
	C++ : ()

	사칙연산자 : +, -, *, /, %(나머지 연산)
	*, /, % 연산이 먼저된다.
	나머지 연산은 A를 B로 나눈 나머지 값을 구해준다.
	10 % 3 = 1

	나머지 연산은 정수 대 정수 연산을 지원한다.
	Number = 3.14f % 322.33f; -> 에러

	나눗셈 연산을 할 때 결과값을 실수형태로 얻고 싶다면
	나눗셈을 수행하는 2개의 값중 1개라도 실수여야 한다.
	A / B 를 수행할 때 둘 다 정수라면 결과도 정수로 나오고 소수점이
	짤린다.
	10 / 3 = 3
	*/
	Number = 10 % 3;

	// %d : 정수값을 받아서 문자열로 변경.
	// %f : 실수값을 받아서 문자열로 변경.
	// %c : 문자 1개를 받아서 문자열로 변경.
	// %s : 문자열을 받아서 문자열로 변경.
	printf("10 %% 3 = %d\n", Number);

	//Number = 10 / 0; -> 에러
	Number = 0 / 10;

	int	Number11 = 10, Number12 = 0;

	//Number = Number / Number12;
	printf("10 / 3 = %d\n", (10 / 3));

	// %.3f 하면 소수점 3번째 자리까지 출력한다는 의미이다.
	// 3.0f = 3.f
	printf("10 / 3 = %.3f\n", (10 / 3.0f));

	/*
	관계연산자 : 두 값을 비교하는 연산자이다. 결과로 참/거짓이
	나오게 된다.
	<, >, <=, >=, ==(같다), !=(다르다)
	*/
	bool	Result = 10 < 20;
	printf("10 < 20 = %d\n", Result);

	Result = 10 > 20;
	printf("10 > 20 = %d\n", Result);

	Result = 10 <= 20;
	printf("10 <= 20 = %d\n", Result);

	Result = 10 >= 20;
	printf("10 >= 20 = %d\n", Result);

	Result = 10 == 20;
	printf("10 == 20 = %d\n", Result);

	Result = 10 != 20;
	printf("10 != 20 = %d\n", Result);

	// 사칙 연산자가 관계연산자보다 우선순위가 높다.
	Result = 10 + 7 > 20 + 2;
	printf("10 * 7 > 20 * 2 = %d\n", Result);

	/*
	논리연산자 : 참/거짓 대 참/거짓을 연산하여 결과로 참/거짓이 나오는
	연산자이다.
	AND(&&), OR(||)(shift + \), NOT(!)
	AND : 둘다 참일 경우만 참이고 아니면 거짓이다.
	OR : 둘중 하나라도 참이면 참이고 아니면 거짓이다.
	A	B	AND	OR
	0	0	0	0
	1	0	0	1
	0	1	0	1
	1	1	1	1

	NOT : 반대로 나온다.
	A	NOT
	0	1
	1	0
	*/
	printf("false && false = %d\n", false && false);
	printf("true && false = %d\n", true && false);
	printf("false && true = %d\n", false && true);
	printf("true && true = %d\n", true && true);

	printf("false || false = %d\n", false || false);
	printf("true || false = %d\n", true || false);
	printf("false || true = %d\n", false || true);
	printf("true || true = %d\n", true || true);

	printf("!false = %d\n", !false);
	printf("!true = %d\n", !true);

	int	MP = 70;
	float	CoolDown = 0.f;

	// 스킬 사용 조건 : 마나가 50 이상이고 스킬 쿨다운이 0초일 경우
	Result = MP >= 50 && CoolDown == 0.f;

	printf("Skill On : %d\n", Result);

	/*
	2진수 : 0, 1 둘중 하나로 표현.
	10진수 : 0 ~ 9 사이의 숫자로 표현.
	16진수 : 0 ~ 15 사이의 숫자로 표현.
	10 ~ 15는 두자리를 차지하기 때문에 a ~ f 로 표현.

	213을 2진수, 16진수로 변환해보자.

	213 / 2 = 106 -- 1
	106 / 2 = 53 --- 0
	53 / 2 = 26 ---- 1
	26 / 2 = 13 ---- 0
	13 / 2 = 6 ----- 1
	6 / 2 = 3 ------ 0
	3 / 2 = 1 ------ 1

	더이상 2로 나눌 수 없다면 마지막 몫부터 거꾸로 읽는다.
	213 = 11010101

	2진수는 앞에 0b를 붙여서 표현한다.

	1   1  0  1  0 1 0 1
	128 64 32 16 8 4 2 1

	128 + 64 + 16 + 4 + 1 = 213

	16진수 1자리는 2진수 4자리를 차지한다.
	1101 / 0101
	8421   8421

	16진수는 앞에 0x를 붙여서 표현한다.
	0xd5

	5 / 2 = 2 -- 1
	2 / 2 = 1 -- 0

	13 / 2 = 6 - 1
	6 / 2 = 3 -- 0
	3 / 2 = 1 -- 1

	11010101

	2진수 단위의 연산은 2가지가 제공된다.
	비트단위 논리연산자, 쉬프트 연산자
	값 대 값을 연산하여 결과로 값이 나오게 된다.

	비트단위 논리연산자 : AND(&), OR(|), NOT(~), XOR(^)
	A와 B를 연산하게 되면 먼저 A와 B를 2진수로 변환하고
	각 자리별로 논리연산을 수행한다.

	A	B	XOR
	0	0	0
	1	0	1
	0	1	1
	1	1	0

	213 : 11010101
	479 : 111011111
	479 & 213 = 213
	 111011111
	&011010101
	 011010101

	479 | 213 = 479
	 111011111
	|011010101
	 111011111

	479 ^ 213 = 266
	 111011111
	^011010101
	 100001010
	 256 + 2 + 8 = 266

	~213 = -214

	~ 00000000 00000000 00000000 11010101
	  11111111 11111111 11111111 00101010
	*/
	printf("479 & 213 = %d\n", 479 & 213);
	printf("479 | 213 = %d\n", 479 | 213);
	printf("479 ^ 213 = %d\n", 479 ^ 213);
	printf("~213 = %d\n", ~213);

	// 0x00000001와 0x1은 같다.
	// 0x00000001 :     1
	// 0x00000002 :    10
	// 0x00000004 :   100
	// 0x00000008 :  1000
	// 0x00000010 : 10000
	const int	Attack = 0x00000001;
	const int	Defense = 0x00000002;
	const int	HPBuf = 0x00000004;
	const int	MPBuf = 0x00000008;
	const int	Critical = 0x00000010;
	
	int	Buf = 0;

	// Buf = 0 | 1 = 1
	Buf = Buf | Attack;

	// Buf = 001 | 100 = 101
	Buf = Buf | HPBuf;

	// Buf = 00101 | 10000 = 10101
	Buf = Buf | Critical;

	// Buf = 10101 ^ 00100 = 10001
	Buf = Buf ^ HPBuf;

	// Buf = 10001 ^ 00100 = 10101
	Buf = Buf ^ HPBuf;

	printf("Attack : %d\n", Buf & Attack);
	printf("Defense : %d\n", Buf & Defense);
	printf("HPBuf : %d\n", Buf & HPBuf);
	printf("MPBuf : %d\n", Buf & MPBuf);
	printf("Critical : %d\n", Buf & Critical);

	/*
	01100100
	10011011
	*/

	/*
	쉬프트연산자 : <<, >> 2가지가 있다.

	10 : 1010
	10 << 2 = 101000 = 40
	10 << 3 = 1010000 = 80

	80 >> 2 = 10100 = 20
	80 >> 3 = 1010 = 10
	*/

	/*
	증감연산자 : ++, --

	++ : 1증가
	-- : 1감소
	*/

	int	Number100 = 0;

	// Number100 = Number100 + 20;
	Number100 += 20;
}
